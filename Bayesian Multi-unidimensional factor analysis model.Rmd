---
title: "Bayesian Multi-unidimensional factor analysis model"
author: "Jihang"
date: "12/11/2021"
output: html_document
---

```{r setup, include=FALSE}
setwd("C:/Users/jihan/downloads")
library("MASS")
library("base")
library(rstan)
library(MASS)
library(base)
library(shinystan)
```

```{r}
N = 50                    # Number of participants in a pilot study
C = 5                     # The number of categories for each item
M = 4                     # Number of subtests
P1 = P2 = P3 = P4 = 10    # Number of items in each subtest
P = P1 + P2 + P3 + P4     # Number of total items
K = 6                     # Number of experts
eta = 1/(5*K)             # Variance of mu
T.rho_1=T.rho_2=T.rho_3=T.rho_4=c(0.5,0.3,0.7,0.5,0.3,0.7,0.5,0.5,0.3,0.7)  # True item-to-domain correlations
```

# Simulate the participants response data

Participants' factor scores for the four domains were generated by: $f_i \sim N_4(0,\Sigma)$. 
The latent continuous variable $y^*$ is generated by: $y^*=\rho * f + e$, where $e \sim N(0,1-\rho^2)$. 
We convert $y^*$ to ordinal $y$ using the percentile-based cut points. And the cut points are defined as the 20th, 40th, 60th, and 80th percentile of the standard normal distribution. 
```{r}
set.seed(1000)
sim.ystar=sim.data=matrix(NA,N,P)
mean <- c(0, 0, 0, 0)                                     # Specify the means of the variables
sigma <- matrix(c(1, .8, .8, .8,
                  .8, 1, .8, .8,
                  .8, .8, 1, .8,
                  .8, .8, .8, 1), ncol = 4)          # Specify the covariance matrix of the variables
ft <- mvrnorm(n = N, mu = mean, Sigma = sigma)
for (j in 1:P1){
  sim.ystar[,j]=T.rho_1[j]*ft[,1]+rnorm(N,0,sqrt(1-T.rho_1[j]^2))
}
for (j in (P1+1):(P1+P2)){
  sim.ystar[,j]=T.rho_2[j-P1]*ft[,2]+rnorm(N,0,sqrt(1-T.rho_2[j-P1]^2))
}
for (j in (P1+P2+1):(P1+P2+P3)){
  sim.ystar[,j]=T.rho_3[j-P1-P2]*ft[,3]+rnorm(N,0,sqrt(1-T.rho_3[j-P1-P2]^2))
}
for (j in (P1+P2+P3+1):P){
  sim.ystar[,j]=T.rho_4[j-P1-P2-P3]*ft[,4]+rnorm(N,0,sqrt(1-T.rho_4[j-P1-P2-P3]^2))
}

# Transform continuous y* back to ordinal y
for (j in 1:P){
  sim.data[,j]=cut(sim.ystar[,j],breaks=qnorm(c(0.0,0.2,0.4,0.6,0.8,1.0)),
                   include.lowest=TRUE,labels=FALSE,ordered_result=TRUE)
}
(Y <- sim.data)
```

```{r}
Zero <- c(0,0,0,0) # a vector of Zeros (fixed means for person parameter)
W <- matrix(c(1,0,0,0,
              0,1,0,0,
              0,0,1,0,
              0,0,0,1),4,4) # binary unit matrix
mu_0 <- c(0.5*log((1+T.rho_1)/(1-T.rho_1)),0.5*log((1+T.rho_2)/(1-T.rho_2)),0.5*log((1+T.rho_3)/(1-T.rho_3)),0.5*log((1+T.rho_4)/(1-T.rho_4))) # mu_0 is experts' prior information. It is the true item-to-domain correlation after Fisher's transformation.
#mu_0 <- mu_0+.1

```

```{r}
stan_MIRT_data <- list(
  N=N,
  C=C,
  M=M,
  P1=P1,
  P2=P2,
  P3=P3,
  P4=P4,
  P=P,
  K=K,
  eta=eta,
  Y=Y,
  Zero=Zero,
  W=W,
  mu_0=mu_0
)
writeLines(readLines("MIRT.stan"))
rstan::rstan_options(auto_write = TRUE)
# complie model
model <- stan_model("MIRT.stan")
fit_MIRT <- sampling(model, stan_MIRT_data, cores = 4, chains = 2, iter = 500, refresh = 0)
options(max.print=999999)

```

```{r}
print(fit_MIRT)
```


